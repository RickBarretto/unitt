as: $[value :any target :type :block][
    to target value
]

define :Summary [
    init: method [passed :integer skipped :integer failed :integer][
        this\passed: passed
        this\skipped: skipped
        this\failed: failed
        this\total: sum @[passed skipped failed]
    ]

    add: method [other :Summary][
        Summary new [
            passed: this\passed + other\passed
            skipped: this\skipped + other\skipped
            failed: this\failed + other\failed
        ]
    ]
]

define :AssertionResult [
    init: constructor [expression :string passed? :logical]

    string: method [][
        status: (this\passed?)?
            -> "✅"
            -> "❌"

        @[status this\expression]
            | join.words
    ]
]

define :TestResult [
    init: method [description :string assertions :block][
        this\description: description
        this\assertions: to [:AssertionResult] assertions
     
        this\summary: to :Summary #[
            passed: select this\assertions 'a [a\passed?] | size
            failed: select this\assertions 'a [not? a\passed?] | size
            skipped: (empty? this\assertions)? -> 1 -> 0
        ]
    ]

    string: method [][
        status: (every? this\assertions 'a -> get a 'passed?)?
            -> "✅"
            -> "❌"

        if empty? this\assertions -> status: "⏩"

        description: @[status "-" this\description]
            | join.words

        assertions: this\assertions 
            | as [:string]
            | map => indent

        @[description assertions]
            | flatten
            | join.lines
    ]
]

define :StandaloneResult [
    init: method [tests :block][
        this\tests: to [:TestResult] tests

        this\summary: to :Summary #[
            passed: map this\tests 't [t\summary\passed] | sum
            failed: map this\tests 't [t\summary\failed] | sum
            skipped: map this\tests 't [t\summary\skipped] | sum
        ]
    ]

    string: method [][
        if empty? this\tests -> return ""

        tests: this\tests
            | as [:string]
            | map => indent

        @["Standalone Tests:" tests]
            | flatten
            | join.with: "\n\n"
    ]
]

define :SpecResult [
    init: method [description :string tests :block][
        this\description: description
        this\tests: to [:TestResult] tests

        this\summary: to :Summary #[
            passed: map this\tests 't [t\summary\passed] | sum
            failed: map this\tests 't [t\summary\failed] | sum
            skipped: map this\tests 't [t\summary\skipped] | sum
        ]
    ]

    string: method [][
        description: @["Describe:" this\description]
            | join.words

        tests: this\tests
            | as [:string]
            | map => indent

        @[description tests]
            | flatten
            | join.with: "\n\n"
    ]
]

define :FileResult [
    init: method [filename :string standalone :block specs :block][
        this\filename: filename
        this\standalone: standalone
        this\specs: specs
    ]

    summary: method [][
        to :Summary #[
            passed: 1
            failed: 1
            skipped: 1
        ]
    ]

    string: method [][
        filename: @["========" this\filename "========"]
            | join.words

        standalone: @[@[this\standalone]]
            | as [:StandaloneResult]
            | as [:string]

        specs: this\specs
            | as [:SpecResult]
            | as [:string]

        @[
            filename 
            if empty? standalone -> standalone 
            specs
        ] | flatten
          | join.with: "\n\n"
    ]

]

define :Result [
    init: method [files :block][
        this\files: files 
            | map => [read.json &]
            | map => [to :FileResult &]   
    ]

    string: method [][
        this\files
            | join.with: "\n\n\n\n"
            | append "\n" 
    ]
]

findResults: $[at :string][
    files: at 
        | list.recursive 
        | map => normalize

    to :Result [files]
]

