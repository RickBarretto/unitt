
debug: $[x][x]

unittEval: $[tokens][
    expressable?: $[token][in? type token [:string]]

    reprToken: $[token :any][
        discard debug token
        when [
            inline? token               -> unittEval token
            expressable? token          -> express token
            true -> token
        ]
    ]

    tokens | map => [reprToken &] 
           | join.with: " "
]


define :UnittTest [
    init: method [description :string][
        this\description: description
        this\assertions: []
    ]

    dictionary: method [][
        #[description: this\description assertions: this\assertions]
    ]

    expects: method.public [expression :block][
        candidates: @[attr 'with attr 'to attr 'be ] | filter => null?

        unless empty? candidates -> 
            expression: prepend expression @[to :word last candidates]

        display: unittEval expression
        result: equal? @expression @[true]

        this\assertions: this\assertions ++ @[@[display result]]
    ]
]


if standalone? ::

    debug: $[x][inspect dup x]

    api: to :UnittTest ["API Tests"]!
    api\expects [equal? "Hello, World!" "Hello, " ++ "World!"]
    api\expects [not? equal? 5 (mul 2 3)]
    api\expects.to.be: 'true? [true]
    api\expects.be: 'false? [false]
    api\expects.to: 'throws? [[var some]]

    inspect api

    ensure -> equal? api\assertions\0 @[{equal? "Hello, World!" "Hello, " ++ "World!"} true]
    ensure -> equal? api\assertions\1 @[{not? equal? 5 mul 2 3} true]
    ensure -> equal? api\assertions\2 @[{true? true} true]
    ensure -> equal? api\assertions\3 @[{false? false} true]
    ensure -> equal? api\assertions\4 @[{throws? [var some]} true]
