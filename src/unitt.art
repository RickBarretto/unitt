import ./{api/spec}

unitt: [

    init: method [filename][
        this\storage: store.native ".unitt/" ++ filename
        this\storage\standalone: []
        this\storage\specs: []

        this\specs: @[to :UnittStandaloneSpec []!]

        ; Runtime only
        this\kind: 'standalone
        this\spec: first this\specs
        this\test: null
    ]

    describe: method.public [description :string actions :block][
        spec: to :UnittSpec @[description]!

        ; Set the current spec to context
        this\kind: 'spec
        this\spec: spec

        ; Eval and register Spec
        do actions
        this\specs: this\specs ++ this\spec

        ; Update storage at real-time for specs
        this\storage\specs: to [:dictionary] drop this\specs

        ; Reset the current spec to standalone
        this\kind: 'standalone
        this\spec: first this\specs
        this\test: null
    ]

    it: method.public [expectation :string action :block][

        ; Current test context
        test: to :UnittTest [expectation]!
        this\test: test

        ; Eval and register Test
        do action        
        this\spec\test this\test

        ; Update for standalone
        if this\kind = 'standalone [
            set this\specs 0 this\spec
        ]

        ; Update storage at real-time for standalone tests
        this\storage\standalone: @first this\specs
        this\test: null
    ]

    expects: method.public [expression :block][
        this\test\expects expression
    ]

    debug: method.public [][
        print ["--- DEBUG UNITT ---"]
        inspect this\specs
        print "---------------------"
    ]
]!


export module.with: @[(args\["filename"]) ?? unique.id "unitt-"] unitt!

suite: var 'describe
test: var 'it
assert: var 'expects


if standalone? ::

    it "Simple failing test" [
        expects -> false
    ]

    describe "simple append" [
        it "keeps the order" [
            expects [equal? [a b c d]     [a] ++ [b c d]]
            expects.be: 'equal?     @[[a b c d]     [a] ++ [b c d]]
            expects.be: 'equal?     @[["b" "c" "d" "a"]     ["b" "c" "d"] ++ ["a"]]
            expects.be: 'notEqual?  @[["a" "b" "c" "d"]     ["b" "c" "d"] ++ ["a"]]
        ]

        it.skip "has ++ as alias (todo)" [
            expects.be: 'equal? @[append [] [] [] ++ [] ]
            expects.be: 'equal? @[append ["a" "b" "c"] ["a" "b"] ["a" "b" "c"] ++ ["a" "b"] ]
        ]
    ]

    describe "simple append 2" [
        it "keeps the order" [
            expects [equal? [a b c d]     [a] ++ [b c d]]
            expects.be: 'equal?     @[[a b c d]     [a] ++ [b c d]]
            expects.be: 'equal?     @[["b" "c" "d" "a"]     ["b" "c" "d"] ++ ["a"]]
            expects.be: 'notEqual?  @[["a" "b" "c" "d"]     ["b" "c" "d"] ++ ["a"]]
        ]

        it.skip "has ++ as alias (todo) 2" [
            expects.be: 'equal? @[append [] [] [] ++ [] ]
            expects.be: 'equal? @[append ["a" "b" "c"] ["a" "b"] ["a" "b" "c"] ++ ["a" "b"] ]
        ]
    ]

    it "Simple passing test" [
        expects -> true
    ]

    debug
