;; author: « RickBarretto
;; year: 2024-2025
;; licence: « MIT
;; version: 2.0.0-beta
;; repository: « https://github.com/RickBarretto/unitt
;;
;; warning: {
;;    Never import this as lean, or this will break the whole code.
;;    At least, for now. This may change in future updates.
;; }
;;
;; export: ['test 'suite]


define :UnittSpec [

    init: constructor [description :string tests :array]

    run: method [][]

    dictionary: method [][
        #[
            description: this\description
            tests: this\tests
        ]
    ]

]


unitt: [

    init: method [file :string][
        this\file: #[
            standalone: []
            specs: []
        ]

        this\current: null
        this\moduleLevel?: true
        this\filename: file ++ ".json"
    ]

    describe: method.public [description :string tests :block][
        ;; description: « Visually groups tests.
        ;;
        ;; arguments: [
        ;;      description: « the suite description
        ;;      test: « the block containing the tests statements
        ;; ]
        ;; options: [
        ;;      prop: :logical « defines if a test is property-based
        ;;      skip: :logical « skip test if true
        ;; ]
        ;;
        ;; example: {
        ;;      ; testAppend.art
        ;;      import {unitt}!
        ;;      
        ;;      unix?: true
        ;;      describe "Groups some tests together" [
        ;;
        ;;          test.prop "appending with keyword or operator has the same behavior" [
        ;;              a: [a b c d e f g]
        ;;              b: [h i j k l m n]
        ;;              assert.with: 'equal? @[express append a b express a ++ b]
        ;;          ]
        ;;          
        ;;          test.skip: unix? "split is working for windows's paths" [
        ;;              assert.with: 'equal? @[["." "splited" "path"] split.path ".\\splited\\path"]
        ;;          ]
        ;;      ]
        ;;      ; Description: Groups some tests together 
        ;;      ;
        ;;      ; ✅ - assert that appending with keyword or operator has the same behavior
        ;;      ;      ✅: equal? [a b c d e f g h i j k l m n] [a b c d e f g h i j k l m n]
        ;;      ;
        ;;      ; ⏩ - assert that split is working for windows's paths
        ;;      ;      skipped!
        ;; }

        this\moduleLevel?: false
        this\current: to :UnittSpec @[description tests]
        this\current\run
        this\file\specs: append this\file\specs this\current
        this\moduleLevel?: true
        this\current: null
    ]

    it: method.public [description :string testCase :block][
        ;; description: {
        ;;    Run an unit-test, printing it's result.
        ;;    Assertions should be done with the internal function `expects :block`.
        ;; }
        ;; arguments: [
        ;;      description: « the test description
        ;;      testCase: {
        ;;          the block containing the test's logic and assertion
        ;;      }
        ;; ]
        ;; options: [
        ;;      skip: :logical « skip test if true
        ;; ]
        ;;
        ;; note: {
        ;;    * `expects`/`assert` is injected, and only available inside the `it`'s block.
        ;; }
        ;; 
        ;; example: {
        ;;      ; testAppend.art
        ;;      import {unitt}!
        ;;      
        ;;      it "appending with keyword or operator has the same behavior" [
        ;;          a: [a b c d e f g]
        ;;          b: [h i j k l m n]
        ;;
        ;;          expects.be: 'equal? @[express append a b express a ++ b]
        ;;          expects.be: 'equal? @[express append b a express b ++ a]
        ;;      ]
        ;;      ; ✅ - assert that appending with keyword or operator has the same behavior 
        ;;      ;      ✅: equal? [a b c d e f g h i j k l m n] [a b c d e f g h i j k l m n]
        ;;      ;
        ;;      ; ✅ - assert that appending with keyword or operator has the same behavior
        ;;      ;      ✅: equal? [h i j k l m n a b c d e f g] [h i j k l m n a b c d e f g]
        ;;          
        ;;      it.skip: unix? "split is working for windows's paths" [
        ;;          expects.be: 'equal? ["." "splited" "path"] = split.path ".\\splited\\path"
        ;;      ]
        ;;      ; # running on Windows:
        ;;      ; ✅ - assert that split is working for windows's paths
        ;;      ;      ✅: equal? ["." "splited" "path"] ["." "splited" "path"]
        ;;      ; 
        ;;      ; # running on Unix:
        ;;      ; ⏩ - assert that split is working for windows's paths 
        ;;      ;      skipped!
        ;;      
        ;;      it "`a` won't be evaluated" [
        ;;          expects.static -> a = 5 
        ;;      ]
        ;;      ; ✅ - assert that `a` won't be evaluated 
        ;;      ;      ✅: a = 5
        ;;
        ;; }

        ; erases the test case if this must be skipped
        ; basically the same as run an empty block.
        if attr 'skip -> testCase: []

        __assertions: []
        expects: $[condition :block][
            ; The injected function wrapped into a block that will evaluate the expression.
            ; This function is injected by using: .be:, .to: or .to.be:
            __fn: @[attr 'with attr 'to attr 'be ] | filter => null?

            ; When using `expects.be: 'fn`, `fn` is the function to be called.
            if not? empty? __fn 
                -> condition: prepend condition @[to :word last __fn]

            '__assertions ++ @[condition]
        ]
        assert: var 'expects

        do testCase

        ; Maps to [representation :string, status :logical]
        __this_test: #[
            description: description 
            assertions: map __assertions 'x [@[\expr x, equal? @x @[true]]]
        ]

        inspect this\currentSpec

        (this\standalone?)?
            [this\file\standalone: append this\file\standalone __this_test]
            [this\currentSpec\tests: append this\currentSpec\tests __this_test]

        if this\standalone?
            -> write.json this\file this\filename
    ]

    expr: method [tokens][
        ignorable: [
            :function 
            :literal 
            :pathLiteral 
            :method 
            :object
            :symbol
        ]

        reprToken: $[token :any][
            ; :inline should be recursively evaluated 
            if inline? token -> return \expr token

            ; :string, :literal, :pathLiteral and :symbolLiteral should be returned as is
            if contains? [:string :literal :pathLiteral :symbolLiteral] type token 
                -> return express token

            ; if the evaluation throws, return the token as is
            if throws? [value: var token] -> return token

            ; otherwise, evaluate the token
            switch in? (type var token) ignorable
                -> token
                -> express value
        ]

        ; joins the representation of all tokens with space
        tokens | map => [reprToken &] | join.with: " "
    ]

]!

filename: (key? args 'filename)? [args\filename] [unique.id "unitt"]
export module.with: @[~".unitt/|filename|"] unitt!

suite: var 'describe
spec: var 'describe
test: var 'it
