import ./{api/spec}

unitt: [

    init: method [][
        this\specs: @[
            to :UnittStandaloneSpec []!
        ]

        ; Runtime only
        this\kind: 'standalone
        this\spec: first this\specs
        this\test: null
    ]

    describe: method.public [description :string actions :block][
        spec: to :UnittSpec @[description]!

        ; Set the current spec to context
        this\kind: 'spec
        this\spec: spec

        ; Eval and register Spec
        do actions
        this\specs: this\specs ++ this\spec

        ; Reset the current spec to standalone
        this\kind: 'standalone
        this\spec: first this\specs
        this\test: null
    ]

    it: method.public [expectation :string action :block][

        ; Current test context
        test: to :UnittTest [expectation]!
        this\test: test

        ; Eval and register Test
        do action        
        this\spec\test this\test

        ; Update for standalone
        if this\kind = 'standalone [
            set this\specs 0 this\spec
        ]

        this\test: null
    ]

    expects: method.public [expression :block][
        this\test\expects expression
    ]

    debug: method.public [][
        print ["--- DEBUG UNITT ---"]
        inspect this\specs
        print "---------------------"
    ]

    unittWrite: method.public [file :string][
        data: #[
            stadalone: @first this\specs
            specs: to [:dictionary] drop this\specs
        ]

        write.json data file
    ]

]!


export module unitt!


if standalone? ::

    it "Simple failing test" [
        expects -> false
    ]

    describe "simple append" [
        it "keeps the order" [
            expects [equal? [a b c d]     [a] ++ [b c d]]
            expects.be: 'equal?     @[[a b c d]     [a] ++ [b c d]]
            expects.be: 'equal?     @[["b" "c" "d" "a"]     ["b" "c" "d"] ++ ["a"]]
            expects.be: 'notEqual?  @[["a" "b" "c" "d"]     ["b" "c" "d"] ++ ["a"]]
        ]

        it.skip "has ++ as alias (todo)" [
            expects.be: 'equal? @[append [] [] [] ++ [] ]
            expects.be: 'equal? @[append ["a" "b" "c"] ["a" "b"] ["a" "b" "c"] ++ ["a" "b"] ]
        ]
    ]

    describe "simple append 2" [
        it "keeps the order" [
            expects [equal? [a b c d]     [a] ++ [b c d]]
            expects.be: 'equal?     @[[a b c d]     [a] ++ [b c d]]
            expects.be: 'equal?     @[["b" "c" "d" "a"]     ["b" "c" "d"] ++ ["a"]]
            expects.be: 'notEqual?  @[["a" "b" "c" "d"]     ["b" "c" "d"] ++ ["a"]]
        ]

        it.skip "has ++ as alias (todo) 2" [
            expects.be: 'equal? @[append [] [] [] ++ [] ]
            expects.be: 'equal? @[append ["a" "b" "c"] ["a" "b"] ["a" "b" "c"] ++ ["a" "b"] ]
        ]
    ]

    it "Simple passing test" [
        expects -> true
    ]

    debug
    unittWrite "unitt_results.json"
