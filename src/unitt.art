;; author: « RickBarretto
;; year: 2024-2026
;; licence: « MIT
;; version: 3.0.3
;; repository: « https://github.com/RickBarretto/unitt
;; installation: « arturo -p install unitt
;;
;; warning: {
;;    Never import this as lean, or this will break the whole code.
;;    At least, for now. This may change in future updates.
;; }
;;
;; export: ['unitt 'test 'suite 'describe 'it 'assert 'expects]

import ./{api/result}!
import ./{api/spec}!

define :Unitt [
    init: method [][
        this\_results: ø
    ]

    _getResults: method [][
        unless this\_results ->
            this\_results: to :FileResult [
                ""
                _unitt\standalone
                _unitt\specs
            ]!
    
        this\_results
    ]

    report: method [what :literal][
        ensure -> in? what ['full 'minimal]

        result: \_getResults!

        case what [
            'full [print to :string do [result]]
            'minimal [print to :string do [result\clean]]
        ]

        print to :string result\summary
    ]

    exit: method [][
        result: \_getResults!
        result\failed? ?
            -> panic.unstyled "Some tests failed!"
            -> exit 0
    ]
]!

unittModule: [

    init: method [][
        this\storage: (key? args 'filename)?
            -> store.json args\filename ++ ".json"
            -> #[]

        this\storage\filename: (key? args 'filename)?
            [args\filename | split.path | drop | join.path]
            ["Standalone File Test"]

        this\storage\standalone: []
        this\storage\specs: []

        this\specs: @[to :UnittStandaloneSpec []!]

        ; Runtime only
        this\kind: 'standalone
        this\spec: first this\specs
        this\test: null
    ]

    _unitt: method.public [][
        this\storage
    ]

    describe: method.public [description :string actions :block][
        ;; description: « Groups tests.
        ;;
        ;; arguments: [
        ;;      description: « the suite description
        ;;      actions: « the block containing the tests statements
        ;; ]
        ;;
        ;; example: {
        ;;      ; testAppend.art
        ;;      import {unitt}!
        ;;      
        ;;      unix?: true
        ;;      describe "Groups some tests together" [
        ;;
        ;;          it "appending with keyword or operator has the same behavior" [
        ;;              a: [a b c d e f g]
        ;;              b: [h i j k l m n]
        ;;              assert.with: 'equal? @[express append a b express a ++ b]
        ;;          ]
        ;;          
        ;;          it.skip: unix? "split is working for windows's paths" [
        ;;              assert.with: 'equal? @[["." "splited" "path"] split.path ".\\splited\\path"]
        ;;          ]
        ;;      ]
        ;;      ; Description: Groups some tests together 
        ;;      ;
        ;;      ; ✅ - assert that appending with keyword or operator has the same behavior
        ;;      ;      ✅: equal? [a b c d e f g h i j k l m n] [a b c d e f g h i j k l m n]
        ;;      ;
        ;;      ; ⏩ - assert that split is working for windows's paths
        ;;      ;      skipped!
        ;; }

        spec: to :UnittSpec @[description]!

        ; Set the current spec to context
        this\kind: 'spec
        this\spec: spec

        ; Eval and register Spec
        do actions
        this\specs: this\specs ++ this\spec

        ; Update storage at real-time for specs
        this\storage\specs: to [:dictionary] drop this\specs

        ; Reset the current spec to standalone
        this\kind: 'standalone
        this\spec: first this\specs
        this\test: null
    ]

    it: method.public [expectation :string action :block][
        ;; description: {
        ;;    Attaches a test case to the current running suite.
        ;;    Assertions should be done with `expects :block`.
        ;; }
        ;; arguments: [
        ;;      expectation: « the test description
        ;;      action: {
        ;;          the block containing the test's logic and assertion
        ;;      }
        ;; ]
        ;; options: [
        ;;      skip: :logical « skip test if true
        ;; ]
        ;; 
        ;; example: {
        ;;      ; testAppend.art
        ;;      import {unitt}!
        ;;      
        ;;      it "appending with keyword or operator has the same behavior" [
        ;;          a: [a b c d e f g]
        ;;          b: [h i j k l m n]
        ;;
        ;;          expects.be: 'equal? @[express append a b express a ++ b]
        ;;          expects.be: 'equal? @[express append b a express b ++ a]
        ;;      ]
        ;;      ; ✅ - assert that appending with keyword or operator has the same behavior 
        ;;      ;      ✅: equal? [a b c d e f g h i j k l m n] [a b c d e f g h i j k l m n]
        ;;      ;
        ;;      ; ✅ - assert that appending with keyword or operator has the same behavior
        ;;      ;      ✅: equal? [h i j k l m n a b c d e f g] [h i j k l m n a b c d e f g]
        ;;          
        ;;      it.skip: unix? "split is working for windows's paths" [
        ;;          expects.be: 'equal? ["." "splited" "path"] = split.path ".\\splited\\path"
        ;;      ]
        ;;      ; # running on Windows:
        ;;      ; ✅ - assert that split is working for windows's paths
        ;;      ;      ✅: equal? ["." "splited" "path"] ["." "splited" "path"]
        ;;      ; 
        ;;      ; # running on Unix:
        ;;      ; ⏩ - assert that split is working for windows's paths 
        ;;      ;      skipped!
        ;;      
        ;;      it "`a` won't be evaluated" [
        ;;          expects.static -> a = 5 
        ;;      ]
        ;;      ; ✅ - assert that `a` won't be evaluated 
        ;;      ;      ✅: a = 5
        ;;
        ;; }

        ; Current test context
        test: to :UnittTest [expectation]!
        this\test: test

        ; Eval and register Test
        do action        
        this\spec\test this\test

        ; Update for standalone
        if this\kind = 'standalone [
            set this\specs 0 this\spec
        ]

        ; Update storage at real-time for standalone tests
        this\storage\standalone: to :block first this\specs
        this\test: null
    ]

    expects: method.public [expression :block][
        ;; description: {
        ;;    Add the assertion to the current running test unit. 
        ;;
        ;;    Important to know that the expression is not evaluated at the 
        ;;    assertion moment, but at the end of the test execution.
        ;;    Not eveything there is also evaluates, 
        ;;    and some values may be displayed as they are.
        ;; }
        ;; arguments: [
        ;;      expression: « the expression to be asserted.
        ;; ]
        ;;
        ;; options: [
        ;;      be: :literal {
        ;;          the function to be used for assertion, if not provided, 
        ;;          the expression will be evaluated as a boolean.
        ;;          When using this, the block becomes the parameters 
        ;;          of the function.
        ;;      }
        ;;      to: :literal « same as above.
        ;; ]
        ;; 
        ;; example: {
        ;;      ; testAppend.art
        ;;      import {unitt}!
        ;;      
        ;;      it "appending with keyword or operator has the same behavior" [
        ;;          a: [a b c d e f g]
        ;;          b: [h i j k l m n]
        ;;
        ;;          expects.be: 'equal? @[express append a b express a ++ b]
        ;;          expects.be: 'equal? @[express append b a express b ++ a]
        ;;      ]
        ;;      ; ✅ - assert that appending with keyword or operator has the same behavior 
        ;;      ;      ✅: equal? [a b c d e f g h i j k l m n] [a b c d e f g h i j k l m n]
        ;;      ;
        ;;      ; ✅ - assert that appending with keyword or operator has the same behavior
        ;;      ;      ✅: equal? [h i j k l m n a b c d e f g] [h i j k l m n a b c d e f g]
        ;;
        ;; }

        if this\test = null [
            panic "expects should be used inside a test block"
        ]

        this\test\expects expression
    ]
]!


export module unittModule!

suite: var 'describe
test: var 'it
assert: var 'expects

unitt: to :Unitt []!

if standalone? ::

    it "Simple failing test" [
        expects -> false
    ]

    describe "simple append" [
        it "keeps the order" [
            expects [equal? [a b c d]     [a] ++ [b c d]]
            expects.be: 'equal?     @[[a b c d]     [a] ++ [b c d]]
            expects.be: 'equal?     @[["b" "c" "d" "a"]     ["b" "c" "d"] ++ ["a"]]
            expects.be: 'notEqual?  @[["a" "b" "c" "d"]     ["b" "c" "d"] ++ ["a"]]
        ]

        it.skip "has ++ as alias (todo)" [
            expects.be: 'equal? @[append [] [] [] ++ [] ]
            expects.be: 'equal? @[append ["a" "b" "c"] ["a" "b"] ["a" "b" "c"] ++ ["a" "b"] ]
        ]
    ]

    describe "simple append 2" [
        it "keeps the order" [
            expects [equal? [a b c d]     [a] ++ [b c d]]
            expects.be: 'equal?     @[[a b c d]     [a] ++ [b c d]]
            expects.be: 'equal?     @[["b" "c" "d" "a"]     ["b" "c" "d"] ++ ["a"]]
            expects.be: 'notEqual?  @[["a" "b" "c" "d"]     ["b" "c" "d"] ++ ["a"]]
        ]

        it.skip "has ++ as alias (todo) 2" [
            expects.be: 'equal? @[append [] [] [] ++ [] ]
            expects.be: 'equal? @[append ["a" "b" "c"] ["a" "b"] ["a" "b" "c"] ++ ["a" "b"] ]
        ]
    ]

    it "Simple passing test" [
        expects -> true
    ]

    unitt\report 'full
    print "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~"
    unitt\report 'minimal
    unitt\exit