======== .unitt\specs\example.spec.art ========

Describe: group 1

    ⏩ - ...

Describe: group 2

    ⏩ - ...
    
    ⏩ - ...

======== .unitt\specs\simple.spec.art ========

Describe: I'm a scope

    ⏩ - should be into Scope #1
    
    ❌ - should be into Scope #1
        ❌: false

Describe: scope #2

    ✅ - should be into Scope #2
        ✅: true

======== .unitt\specs\lib\comparison\between.spec.art ========

Describe: Test generic assertions

    ✅ - Alias has the same behavior
        ✅: equal? between? 1 0 2 1 <=> 0 2
    
    ✅ - between recorgnizes numeric order
        ✅: between? 1 0 2
    
    ✅ - between recorgnizes alphabetic order
        ✅: between? "c" "a" "d"
    
    ✅ - value is between if it's equal to one of the bounds
        ✅: between? 1 1 0
        ✅: between? 1 0 1
    
    ✅ - middle is not between start..end, if middle < start
        ✅: not? between? 5 8 10
    
    ✅ - middle is not between start..end, if middle > end
        ✅: not? between? 6 1 5
    
    ✅ - works on reverse order
        ✅: between? 5 10 0
        ✅: between? "g" "z" "a"

Describe: Test numeric-like values

    ✅ - start < middle < end, for :rational and :floating
        ✅: between? 3/2 1/1 2/1
        ✅: between? 1.5 1/1 2/1
        ✅: between? 3/2 1/1 2.0
        ✅: between? 3/2 1.0 2/1
        ✅: between? 3/2 1.0 2.0
        ✅: between? 1.5 1.0 2/1
    
    ✅ - start < middle < end, for :currency
        ✅: between? 1.5 usd start end
        ✅: between? 1.5 usd start end
        ✅: between? 1.5 usd start end
        ✅: between? 1.5 usd start end
    
    ✅ - start < middle < end, for :complex's real
        ✅: between? to :complex [1 2] to :complex [0 2] to :complex [2 2]
        ✅: between? to :complex [1 2] to :complex [1 2] to :complex [2 2]
        ✅: not? between? to :complex [0 2] to :complex [1 2] to :complex [2 2]
        ✅: not? between? to :complex [3 2] to :complex [0 2] to :complex [1 2]
    
    ✅ - start < middle < end, for :complex's imaginary
        ✅: between? to :complex [1 1] to :complex [1 0] to :complex [1 2]
        ✅: between? to :complex [1 1] to :complex [1 1] to :complex [1 2]
        ✅: not? between? to :complex [1 0] to :complex [1 1] to :complex [1 2]
        ✅: not? between? to :complex [1 3] to :complex [1 0] to :complex [1 2]

Describe: Test :version values

    ✅ - first < current < final, for :version
        ✅: between? 1.0.0 0.5.0 2.1.5
        ✅: between? 1.1.0 1.0.0 1.2.0
        ✅: between? 1.1.1 1.1.0 1.1.2
    
    ✅ - prereleases always come before normal releases
        ✅: between? 1.1.1-pre 1.1.0-pre 1.1.1-pre
        ✅: between? 1.1.1-pre 1.1.0 1.1.1-pre
        ✅: between? 1.1.1-pre 1.1.0 1.1.1
        ✅: between? 1.1.1-pre 1.1.0-pre 1.1.1

Describe: Test :string-like values

    ✅ - between works with alphabetic order
        ✅: between? middle lower higher
        ✅: between? middle lower higher
        ✅: between? middle lower higher
        ✅: between? middle lower higher
        ✅: between? middle lower higher
        ✅: between? middle lower higher
    
    ✅ - between works for :char
        ✅: between? c b d

Describe: Test :date values

    ✅ - 15th is between 1st .. 30th for the same month
        ✅: between? fifithDay firstDay thirdDay
    
    ✅ - June is between January and December
        ✅: between? june january december
    
    ✅ - XX century is between XIX and XXI
        ✅: between? xxCentury xixCentury xxiCentury
    
    ✅ - father is between grandmother and son
        ✅: between? father grandmother son

======== .unitt\specs\lib\collections\append.spec.art ========

Describe: Generic testing

    ✅ - appending keeps the order
        ✅: [a b c d] = [a] ++ [b c d]
        ✅: [b c d a] = [b c d] ++ [a]
        ✅: [a b c d] <> [b c d] ++ [a]
    
    ✅ - alias works seamlessly
        ✅: equal? append [] [] [] ++ []
        ✅: equal? append [a b c] [a b] [a b c] ++ [a b]

Describe: Test :binary operations

    ✅ - :binary ++ :binary results in :binary
        ✅: binary? append a b
        ✅: binary? append a b
        ✅: binary? append a b
        ✅: binary? append a b
    
    ✅ - :binary ++ :integer results in :binary
        ✅: binary? append a b
        ✅: binary? append a b
        ✅: binary? append a b
        ✅: binary? append a b
        ✅: binary? append a b
        ✅: binary? append a b
        ✅: binary? append a b
        ✅: binary? append a b
    
    ✅ - :binary ++ :binary results in :binary
        ✅: binary? append a b
    
    ✅ - :binary ++ :binary | 00 ++ 01 = 00 01
        ✅: correct = a ++ b
    
    ✅ - :binary ++ :integer | 00 ++ 1 = 00 01
        ✅: correct = a ++ b
    
    ✅ - :binary ++ :binary | in-place has the same behavior
        ✅: ref = inp
    
    ✅ - :binary ++ :integer | in-place has the same behavior
        ✅: reference = inplaced
        ✅: inplaced = pathInplaced

Describe: Test :string operations

    ✅ - :string appending results in :string
        ✅: string? "Art" ++ "uro"
    
    ✅ - :char appending results in :string
        ✅: string? H ++ i
        ✅: string? H ++ "igh"
        ✅: string? "Ph" ++ i
    
    ✅ - :string and :char appending are seamless
        ✅: equal? "Artur" ++ "o" "Artur" ++ o
    
    ✅ - Arturo can be generated from :string and :char appending
        ✅: "Arturo" = "Art" ++ "uro"
        ✅: "Arturo" = "Artur" ++ o
        ✅: "Arturo" = A ++ "rturo"
    
    ✅ - :string ++ :string | in-place has the same behavior
        ✅: reference = inplaced
        ✅: inplaced = pathInplaced
    
    ✅ - :string ++ :char | in-place has the same behavior
        ✅: reference = inplaced
        ✅: inplaced = pathInplaced
    
    ✅ - :char ++ :char | in-place has the same behavior
        ✅: reference = inplaced
        ✅: inplaced = pathInplaced

Describe: Test :block operations

    ✅ - :block appending results in :block
        ✅: block? [] ++ []
        ✅: block? interpreted ++ compiled
    
    ✅ - appending between :blocks does not nest it
        ✅: res = append a b
        ✅: [] = append [] []
        ✅: all? map append a b x [not? block? x]
    
    ✅ - appending :blocks of :T results in :blocks of :T
        ✅: all? map [Arturo] ++ [Python] _0 [string? _0]
        ✅: all? map [1] ++ [2] _0 [integer? _0]
        ✅: all? map [1/2] ++ [2/3] _0 [rational? _0]
    
    ✅ - append empty block with 'x results into [x]
        ✅: res = [] ++ number
    
    ✅ - append empty blocks results on empty block
        ✅: empty? [] ++ []
        ✅: [] = [] ++ []
    
    ✅ - ["A" "r" "t"] = ["A" "r"] ++ ["t"]
        ✅: [A r t] = [A r] ++ [t]
    
    ✅ - :block ++ :any | in-place has the same behavior
        ✅: reference = inplaced
        ✅: inplaced = pathInplaced
        ✅: reference = inplaced
        ✅: inplaced = pathInplaced

Describe: Test magic-methods

    ✅ - append works for magic-methods
        ✅: empty? do [container\_block]
        ✅: equal? [1 2] do [container\append [1 2]]
        ✅: equal? [3 4] do [append container [3 4]]
        ✅: equal? [5 6] do [container ++ [5 6]]

======== .unitt\specs\lib\collections\array.spec.art ========

Describe: array.of: :integer

    ✅ - array.of: n returns a n-size :block
        ✅: equal? expected actual
    
    ✅ - array.of: n returns a n-size :block even when the source is a :block
        ✅: equal? expected actual

Describe: array.of: :block - n-dimensional arrays

    ✅ - array.of: [3 4] returns a 3x4 matrix :block
        ✅: equal? expected actual
    
    ✅ - array.of: [3 4] returns a 3x4 matrix :block preserving the :block source
        ✅: equal? expected actual
    
    ✅ - array.of: [3 3 3] return a 3-dimensional array
        ✅: equal? expected actual

Describe: array <source>

    ✅ - array :range should return a :block from iteration
        ✅: equal? [1 2 3] @ 1 .. 3
        ✅: equal? [1 2 3] @ 1 .. 3.2
        ✅: equal? [a b c] @ a .. c
    
    ✅ - array :range should respect .step
        ✅: equal? [1 3 5] @ range step 2 1 5
        ✅: equal? [a c] @ range step 2 a c
    
    ✅ - array :block should evaluate it
        ✅: notEqual? expected data
        ✅: equal? expected actual
    
    ✅ - array :any should wrap and evaluate it into a :block
        ✅: notEqual? expected data
        ✅: equal? expected actual

======== .unitt\specs\lib\collections\chop.spec.art ========

Describe: General testing

    ✅ - chop removes the last item from given collection
        ✅: [a b c] = chop [a b c d]
        ✅: [5 6 7] = chop [5 6 7 8]
    
    ✅ - chop.times: 1 is the same as chop
        ✅: equal? chop [a b c d] chop times 1 [a b c d]
    
    ✅ - chop n times is the same as chop.times: n
        ✅: equal? chop chop chop a chop times 3 a
        ✅: equal? chop chop a chop times 2 a
    
    ✅ - chop removes the n last items from given collection
        ✅: [a b c] = chop times 4 [a b c d e f g]
        ✅: [5 6 7] = chop times 2 [5 6 7 8 9]
    
    ✅ - chop empty collection gives an empty block
        ✅: empty? chop []
        ✅: empty? chop times random 0 1000 []

Describe: Test .times's properties

    ✅ - times = size collections gives an empty block
        ✅: empty? chop times neg size a a
        ✅: empty? chop times size a a
    
    ✅ - times > size collection gives an empty block
        ✅: empty? chop times neg inc size a a
        ✅: empty? chop times inc size a a
    
    ✅ - negative times chops the first n items
        ✅: [b c] = chop times neg 1 a
        ✅: [c] = chop times neg 2 a

Describe: Test :block operations

    ✅ - chop :block returns :block
        ✅: block? chop [a b c d e f g]
        ✅: block? chop [a b]
        ✅: block? chop [a]
    
    ✅ - chop :block | in-place has the same behavior
        ✅: reference = inplaced
        ✅: reference = pathInplaced

Describe: Test :string operations

    ✅ - chop :string returns :string
        ✅: string? chop "High"
        ✅: string? chop "Hi"
        ✅: string? chop "H"
    
    ✅ - chop :string | in-place has the same behavior
        ✅: reference = inplaced
        ✅: reference = pathInplaced


========== Summary ==========

  ⏏️   TOTAL: 147 assertions
  ✅  PASSED: 142 assertions
  ⏩ SKIPPED: 4 assertions
  ❌  FAILED: 1 assertion

========== ======= ==========

