======== .unitt\specs\lib\types\to.test.art ========

======== .unitt\specs\lib\exceptions\functions.test.art ========

Describe: Tests the internal functions

    âœ… - thrown error is catched by 'try
        âœ…: not? throws? [error try [throw File not found]]
    
    âœ… - thrown error is catched by 'throws?
        âœ…: not? throws? [a throws? [throw File not found]]
    
    âœ… - try returns the thown error
        âœ…: error? err
    
    âœ… - try returns null is none error is thrown
        âœ…: null? err
    
    âœ… - thrown errors at user level are runtime errors by default
        âœ…: runtimeError = fileNotFound
    
    âœ… - throw's message parameter goes to :error's message member
        âœ…: "File not found" = fileNotFound\message

======== .unitt\specs\lib\exceptions\types.test.art ========

Describe: Test types and its properties

    âœ… - catched error is an :error
        âœ…: error? err
        âœ…: :error = type err
    
    âœ… - :error contains \kind and \message
        âœ…: not? throws? [kind err\kind msg err\message]
    
    âœ… - :error's \kind is an :errorKind
        âœ…: errorKind? err\kind
        âœ…: :errorkind = type err\kind
    
    âœ… - :error's \message is an :string
        âœ…: string? err\message
        âœ…: :string = type err\message

Describe: Test types for :errorKind and custom ones

    â© - custom :errorKinds can be created from :strings
    
    âœ… - custom :errorKinds can't be created from :string-like values
        âœ…: throws? [fileNotFound to :errorkind customLabel]
        âœ…: throws? [fileNotFound to :errorkind customLabel]

======== .unitt\specs\lib\core\let.test.art ========

Describe: Allowed Operations

    âœ… - multiple assignment to a single value when this is not a :block
        âœ…: a = value
        âœ…: b = value
        âœ…: c = value
    
    âœ… - unpacked value always returns a :block
        âœ…: block? unpacker
        âœ…: unpacker = value
    
    âœ… - let can unpack values when the unpacker is on middle
        âœ…: a = 1
        âœ…: b = [2 3 4]
        âœ…: c = 5
    
    âœ… - let can unpack values when the unpacker is on the left
        âœ…: a = [1 2 3]
        âœ…: b = 4
        âœ…: c = 5
    
    âœ… - let can unpack values when the unpacker is on the right
        âœ…: a = 1
        âœ…: b = 2
        âœ…: c = [3 4 5]
    
    âœ… - let can skip values to be unpacked if the unpacker is empty
        âœ…: a = 1
        âœ…: c = 5

Describe: Unallowed Operations

    âœ… - let can't unpack non- :block s
        âœ…: throws? [value 1 [[unpacker]] : value]
    
    âœ… - let can't unpack more than once
        âœ…: throws? [[[a] [b]] : [1 2 3 4]]
    
    âœ… - let can't assign to unknown types
        âœ…: throws? [[* b] : [1 2 3 4]]
        âœ…: throws? [[a [*] c] : [1 2 3 4]]
    
    âœ… - let can't assign when values are missing
        âœ…: throws? [[a b c] : [1 2]]
    
    âœ… - let can't assign when values are missing
        âœ…: throws? [[a b c] : [1 2]]

======== .unitt\specs\lib\core\new.test.art ========

Describe: test if new object reference does not change the older one

    âœ… - change new primitive values does not change the old ones
        âœ…: a <> b
        âœ…: a <> b
        âœ…: a <> b
        âœ…: a <> b
    
    âœ… - change the new block's value does not change the old one
        âœ…: a <> b
    
    âœ… - change the new block's value does not change the old one
        âœ…: a <> b

Describe: test if new allocate the object to a new address

    âœ… - change new primitive values does not change the old ones
        âœ…: addressOfA <> addressOfB
        âœ…: addressOfA <> addressOfB
        âœ…: addressOfA <> addressOfB
        âœ…: addressOfA <> addressOfB

======== .unitt\specs\lib\collections\combine.test.art ========

Describe: General Tests

    âœ… - all combinations of given collection is itself inside a block
        âœ…: equal? @ [someBlock] combine someBlock
    
    âœ… - all repeated combinations of an unitary collectionis itself wrapped into a block
        âœ…: equal? [[A]] combine repeated [A]
    
    âœ… - combine.by: k returns inner values of k size
        âœ…: every? combine by k someBlock el [k = size el]
        âœ…: every? combine repeated by k someBlock el [k = size el]
    
    âœ… - combine A is a shortcut for combine.by: (size A) A
        âœ…: equal? combine someBlock combine by size someBlock someBlock
        âœ…: equal? combine repeated someBlock combine repeated by size someBlock someBlock
    
    âœ… - .count is the size of the combination
        âœ…: equal? size combine by 2 someBlock combine by 2 count someBlock
        âœ…: equal? size combine repeated someBlock combine repeated count someBlock
        âœ…: equal? size combine repeated by 2 someBlock combine repeated by 2 count someBlock
        âœ…: equal? size combine by 0 someBlock combine by 0 count someBlock
        âœ…: equal? size combine repeated by 0 someBlock combine repeated by 0 count someBlock

Describe: Matematical Properties

    âœ… - C[n:n] = 1
        âœ…: 1 = combine count someBlock
        âœ…: 1 = combine count by size someBlock someBlock
    
    âœ… - C[n:0] = 1
        âœ…: 1 = combine count by 0 someBlock
    
    âœ… - C[n:k] = 0, for all k > n
        âœ…: 0 = combine count by inc size someBlock someBlock
    
    âœ… - C[n:k] = 0, for all k < 0
        âœ…: 0 = combine count by neg 1 someBlock
    
    âœ… - C[n:k] = n! / (k! * (n - k)!)
        âœ…: default = combine count by k Set
        âœ…: repeating = combine count repeated by k Set
        âœ…: default = combine count by k Set
        âœ…: repeating = combine count repeated by k Set
        âœ…: default = combine count by k Set
        âœ…: repeating = combine count repeated by k Set
        âœ…: default = combine count by k Set
        âœ…: repeating = combine count repeated by k Set
        âœ…: default = combine count by k Set
        âœ…: repeating = combine count repeated by k Set
        âœ…: default = combine count by k Set
        âœ…: repeating = combine count repeated by k Set
        âœ…: default = combine count by k Set
        âœ…: repeating = combine count repeated by k Set
        âœ…: default = combine count by k Set
        âœ…: repeating = combine count repeated by k Set
        âœ…: default = combine count by k Set
        âœ…: repeating = combine count repeated by k Set
        âœ…: default = combine count by k Set
        âœ…: repeating = combine count repeated by k Set
        âœ…: default = combine count by k Set
        âœ…: repeating = combine count repeated by k Set
        âœ…: default = combine count by k Set
        âœ…: repeating = combine count repeated by k Set

Describe: Specific Tests

    âœ… - combine.repeated [A B C]
        âœ…: result = combine repeated [A B C]
        âœ…: equal? size result combine count repeated [A B C]
    
    âœ… - combine.by: 2 [A B C]
        âœ…: result = combine by 2 [A B C]
        âœ…: equal? size result combine count by 2 [A B C]
    
    âœ… - combine.repeated.by: 2 [A B C]
        âœ…: result = combine repeated by 2 [A B C]
        âœ…: equal? size result combine count repeated by 2 [A B C]
    
    âœ… - combine.repeated.by: 3 [A B]
        âœ…: result = combine repeated by 3 [A B]
        âœ…: equal? size result combine count repeated by 3 [A B]

======== .unitt\specs\lib\collections\contains-.test.art ========

Describe: contains? for :string types

    âœ… - :string may contain :string
        âœ…: contains? "Arturo" "Art"
        âœ…: not? contains? "Arturo" "Ops!"
    
    âœ… - :string may contain :char
        âœ…: contains? "Arturo" A
        âœ…: contains? "Arturo" t
        âœ…: not? contains? "Arturo" i
    
    âœ… - :string may contain :literal
        âœ…: contains? "Arturo" Art
        âœ…: contains? "Arturo" t
        âœ…: not? contains? "Arturo" i
    
    âœ… - :string may contain :regex
        âœ…: contains? "Arturo" [Art]
        âœ…: not? contains? "Arturo" [i]

Describe: contains? for :range types

    âœ… - :range may contain :integer
        âœ…: contains? 1 .. 10 1
        âœ…: contains? 1 .. 10 5
        âœ…: contains? 1 .. 10 7
        âœ…: contains? 1 .. 10 10
        âœ…: not? contains? 1 .. 10 0
    
    âœ… - :range may contain :floating
        âœ…: contains? 1 .. 10 1.0
        âœ…: contains? 1 .. 10 5.0
        âœ…: contains? 1 .. 10 7.0
        âœ…: contains? 1 .. 10 10.0
        âœ…: not? contains? 1 .. 10 0.0
    
    âœ… - :range is a discrete interval
        âœ…: not? contains? 1 .. 10 5.5
        âœ…: not? contains? range step 2 1 10 2

Describe: contains? for :block types

    âœ… - :block may contain :any
        âœ…: contains? sample 1
        âœ…: contains? sample "Example"
        âœ…: contains? sample example
        âœ…: contains? sample []
        âœ…: contains? sample # []
        âœ…: not? contains? sample "Hmm"
    
    âœ… - contains?.deep can find it into nested :blocks
        âœ…: contains? deep [1 2 3 [4 5] 6 7] 3
        âœ…: contains? deep [1 2 3 [4 5] 6 7] 4
        âœ…: contains? deep [1 2 3 [4 5] 6 7] 5
        âœ…: contains? deep [1 2 3 [4 5] 6 7] [4 5]
        âœ…: contains? [1 2 3 [4 5] 6 7] [4 5]
        âœ…: not? contains? [1 2 3 [4 5] 6 7] 4
        âœ…: not? contains? [1 2 3 [4 5] 6 7] 5
    
    âœ… - contains?.deep can't find :dictionary's values into nested :blocks
        âœ…: not? contains? deep @ [# [name Joe]] "Joe"

Describe: contains? for :dictionary types

    âœ… - :dictionary may contain :any
        âœ…: contains? sample "John"
        âœ…: contains? sample "Doe"
        âœ…: contains? sample programmer
        âœ…: contains? sample 22
        âœ…: contains? sample [Arturo Python Ruby Ada Rust Zig Nim]
        âœ…: not? contains? sample "Joe"
        âœ…: not? contains? sample "Jane"
    
    âœ… - contains?.deep can find it into nested :dictionary
        âœ…: contains? deep sample "Joe"
        âœ…: contains? deep sample "Jane"
    
    âœ… - contains?.deep can't find :block's values into nested :dictionary
        âœ…: not? contains? deep sample to :word "Arturo"

Describe: test .at attribute

    âœ… - element at 0 must be equal to first
        âœ…: contains? at 0 str first str
        âœ…: contains? at 0 blk first blk
        âœ…: contains? at 0 dict "Joe"
    
    âœ… - element at high must be equal to last
        âœ…: contains? at dec size str str last str
        âœ…: contains? at dec size blk blk last blk
        âœ…: contains? at 1 dict "Doe"
    
    âœ… - element at x must be equal to get x
        âœ…: contains? at index str str\[index]
        âœ…: contains? at index blk blk\[index]
        âœ…: contains? at index str str\[index]
        âœ…: contains? at index blk blk\[index]
        âœ…: contains? at index str str\[index]
        âœ…: contains? at index blk blk\[index]
        âœ…: contains? at index str str\[index]
        âœ…: contains? at index blk blk\[index]
        âœ…: contains? at index str str\[index]
        âœ…: contains? at index blk blk\[index]
    
    â© - should throw for index out of bounds

======== .unitt\specs\lib\collections\couple.test.art ========

======== .unitt\specs\lib\collections\decouple.test.art ========

======== .unitt\specs\lib\collections\dictionary.test.art ========

Describe: simple dictionary

    âœ… - should store all fields
        âœ…: "John" = actualName
        âœ…: "Doe" = actualSurname
        âœ…: 35 = actualAge

Describe: nested dictionary

    âœ… - should access 1-depth values
        âœ…: "John Doe" = actualFullname
        âœ…: expectedLocation = actualLocation
    
    âœ… - should access n-depth values
        âœ…: "S\xC3\xA3o Paulo" = actualCity
        âœ…: "Brazil" = actualCountry
    
    âœ… - should store keys as lower when .lower
        âœ…: [username] = actual

Describe: Module Specification

    

Describe: scope and evaluation

    âœ… - should read out-of-scope variables
        âœ…: country = actual
    
    âœ… - should not alter outside values with same label
        âœ…: "EU" = entity
        âœ…: "Spain" = country
        âœ…: "Greece" = actual
    
    âœ… - should evaluate functions
        âœ…: 3 = actual
    
    âœ… - should be accessible after a block evaluation
        âœ…: set? example
        âœ…: "value" = example\some

Describe: inject fields with `.with`

    âœ… - should contain ntity field
        âœ…: "EU" = location\entity
    
    âœ… - should keep other fields
        âœ…: "Spain" = location\country
    
    âœ… - should accept [:literal]
        âœ…: "EU" = location\entity
    
    âœ… - should store injected keys as lower when .lower
        âœ…: [entity] = actual

Describe: construction from raw

    âœ… - should store all keys & values in order
        âœ…: [name surname age] = actualKeys
        âœ…: [John Doe 35] = actualValues
    
    âœ… - should not evaluate :block
        âœ…: in? "name" keys actual
        âœ…: in? to :word "john" values actual
        âœ…: not? in? "nome" keys actual
        âœ…: not? in? "Jane" values actual

Describe: dictionary from function

    âœ… - should return dictionary
        âœ…: # [some value] = returnsDict
        âœ…: "value" = actualField
    
    âœ… - should access field direclty for 0-arity
        âœ…: "value" = returnsDict\some


========== Summary ==========

  âï¸   TOTAL: 187 assertions
  âœ…  PASSED: 185 assertions
  â© SKIPPED: 2 assertions
  âŒ  FAILED: 0 assertions

========== ======= ==========

