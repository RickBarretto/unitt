======== .unitt/specs/simple.spec.art ========

Describe: Module's Global Specs

    ✅ - I should be standalone
        ✅: string? "I\'m standalone"
    
    ✅ - I should be standalone #2
        ✅: string? "I\'m standalone"

Describe: I'm a scope

    ⏩ - should be into Scope #1
    
    ❌ - should be into Scope #1
        ❌: false

Describe: scope #2

    ✅ - should be into Scope #2
        ✅: true

======== .unitt/specs/example.spec.art ========

Describe: Module's Global Specs

    ❌ - I'll fail as standalone
        ❌: false
    
    ✅ - string should not be interpolated when not asked for
        ✅: equal? "W | A | S | D" "W | A | S | D"
        ✅: equal? "W | A | S | D" "W | A | S | D"
    
    ✅ - this passes
        ✅: true
        ✅: equal? 3 3
        ✅: equal? 3 add 1 2
        ✅: equal? 3 add 1 2
        ✅: equal? 3 add 1 2
        ✅: equal? 3 add 1 2
    
    ⏩ - this skips
    
    ❌ - this fails
        ✅: true
        ❌: equal? 4 add 1 2
        ✅: equal? 3 add 1 2

Describe: group 1

    ⏩ - ...

Describe: group 2

    ⏩ - ...
    
    ⏩ - ...

======== .unitt/specs/lib/collections/array.spec.art ========

Describe: array.of: :integer

    ✅ - array.of: n returns a n-size :block
        ✅: equal? ['done 'done 'done] ['done 'done 'done]
    
    ✅ - array.of: n returns a n-size :block even when the source is a :block
        ✅: equal? [['done] ['done] ['done]] [['done] ['done] ['done]]

Describe: array.of: :block - n-dimensional arrays

    ✅ - array.of: [3 4] returns a 3x4 matrix :block
        ✅: equal? [[0 0 0 0] [0 0 0 0] [0 0 0 0]] [[0 0 0 0] [0 0 0 0] [0 0 0 0]]
    
    ✅ - array.of: [3 4] returns a 3x4 matrix :block preserving the :block source
        ✅: equal? [[[0] [0] [0] [0]] [[0] [0] [0] [0]] [[0] [0] [0] [0]]] [[[0] [0] [0] [0]] [[0] [0] [0] [0]] [[0] [0] [0] [0]]]
    
    ✅ - array.of: [3 3 3] return a 3-dimensional array
        ✅: equal? [[[:point :point :point] [:point :point :point] [:point :point :point]] [[:point :point :point] [:point :point :point] [:point :point :point]] [[:point :point :point] [:point :point :point] [:point :point :point]]] [[[:point :point :point] [:point :point :point] [:point :point :point]] [[:point :point :point] [:point :point :point] [:point :point :point]] [[:point :point :point] [:point :point :point] [:point :point :point]]]

Describe: array <source>

    ✅ - array :range should return a :block from iteration
        ✅: equal? [1 2 3] @ 1 .. 3
        ✅: equal? [1 2 3] @ 1 .. 3.2
        ✅: equal? [a b c] @ a .. c
    
    ✅ - array :range should respect .step
        ✅: equal? [1 3 5] @ range step 2 1 5
        ✅: equal? [a c] @ range step 2 a c
    
    ✅ - array :block should evaluate it
        ✅: notEqual? ["Arturo" "is awesome!"] [append "Art" "uro" join .with: " " ["is" "awesome!"]]
        ✅: equal? ["Arturo" "is awesome!"] ["Arturo" "is awesome!"]
    
    ✅ - array :any should wrap and evaluate it into a :block
        ✅: notEqual? [3.141592653589793] [pi]
        ✅: equal? [3.141592653589793] [3.141592653589793]

======== .unitt/specs/lib/collections/append.spec.art ========

Describe: Generic testing

    ✅ - appending keeps the order
        ✅: [a b c d] = [a] ++ [b c d]
        ✅: [b c d a] = [b c d] ++ [a]
        ✅: [a b c d] <> [b c d] ++ [a]
    
    ✅ - alias works seamlessly
        ✅: equal? append [] [] [] ++ []
        ✅: equal? append [a b c] [a b] [a b c] ++ [a b]

Describe: Test :binary operations

    ✅ - :binary ++ :binary results in :binary
        ✅: binary? append  
        ✅: binary? append  
        ✅: binary? append  
        ✅: binary? append  
    
    ✅ - :binary ++ :integer results in :binary
        ✅: binary? append  1
        ✅: binary? append  1
        ✅: binary? append  1
        ✅: binary? append  1
        ✅: binary? append  1
        ✅: binary? append  1
        ✅: binary? append  1
        ✅: binary? append  1
    
    ✅ - :binary ++ :binary results in :binary
        ✅: binary? append  
    
    ✅ - :binary ++ :binary | 00 ++ 01 = 00 01
        ✅:  =  ++ 
    
    ✅ - :binary ++ :integer | 00 ++ 1 = 00 01
        ✅:  =  ++ 1
    
    ✅ - :binary ++ :binary | in-place has the same behavior
        ✅:  = 
    
    ✅ - :binary ++ :integer | in-place has the same behavior
        ✅:  = 
        ✅:  = 

Describe: Test :string operations

    ✅ - :string appending results in :string
        ✅: string? "Art" ++ "uro"
    
    ✅ - :char appending results in :string
        ✅: string? H ++ i
        ✅: string? H ++ "igh"
        ✅: string? "Ph" ++ i
    
    ✅ - :string and :char appending are seamless
        ✅: equal? "Artur" ++ "o" "Artur" ++ o
    
    ✅ - Arturo can be generated from :string and :char appending
        ✅: "Arturo" = "Art" ++ "uro"
        ✅: "Arturo" = "Artur" ++ o
        ✅: "Arturo" = A ++ "rturo"
    
    ✅ - :string ++ :string | in-place has the same behavior
        ✅: "Arturo" = "Arturo"
        ✅: "Arturo" = "Arturo"
    
    ✅ - :string ++ :char | in-place has the same behavior
        ✅: "Arturo" = "Arturo"
        ✅: "Arturo" = "Arturo"
    
    ✅ - :char ++ :char | in-place has the same behavior
        ✅: "Hi" = "Hi"
        ✅: "Hi" = "Hi"

Describe: Test :block operations

    ✅ - :block appending results in :block
        ✅: block? [] ++ []
        ✅: block? ["Arturo" "Ruby" "Python" "Wren"] ++ ["C" "C++" "Nim" "Rust" "Smalltalk"]
    
    ✅ - appending between :blocks does not nest it
        ✅: ["Arturo" "Smalltalk"] = append ["Arturo"] ["Smalltalk"]
        ✅: [] = append [] []
        ✅: all? map append ["Arturo"] ["Smalltalk"] 'x [not? block? x]
    
    ✅ - appending :blocks of :T results in :blocks of :T
        ✅: all? map [Arturo] ++ [Python] '_0 [string? _0]
        ✅: all? map [1] ++ [2] '_0 [integer? _0]
        ✅: all? map [1/2] ++ [2/3] '_0 [rational? _0]
    
    ✅ - append empty block with 'x results into [x]
        ✅: [39] = [] ++ 39
    
    ✅ - append empty blocks results on empty block
        ✅: empty? [] ++ []
        ✅: [] = [] ++ []
    
    ✅ - ["A" "r" "t"] = ["A" "r"] ++ ["t"]
        ✅: [A r t] = [A r] ++ [t]
    
    ✅ - :block ++ :any | in-place has the same behavior
        ✅: [a b c 5] = [a b c 5]
        ✅: [a b c 5] = [a b c 5]
        ✅: [a b c 5] = [a b c 5]
        ✅: [a b c 5] = [a b c 5]

Describe: Test magic-methods

    ✅ - append works for magic-methods
        ✅: empty? do [container\_block]
        ✅: equal? [1 2] do [container\append [1 2]]
        ✅: equal? [3 4] do [append container [3 4]]
        ✅: equal? [5 6] do [container ++ [5 6]]

======== .unitt/specs/lib/collections/chop.spec.art ========

Describe: General testing

    ✅ - chop removes the last item from given collection
        ✅: [a b c] = chop [a b c d]
        ✅: [5 6 7] = chop [5 6 7 8]
    
    ✅ - chop.times: 1 is the same as chop
        ✅: equal? chop [a b c d] chop times 1 [a b c d]
    
    ✅ - chop n times is the same as chop.times: n
        ✅: equal? chop chop chop [a b c d e f g] chop times 3 [a b c d e f g]
        ✅: equal? chop chop [a b c d e f g] chop times 2 [a b c d e f g]
    
    ✅ - chop removes the n last items from given collection
        ✅: [a b c] = chop times 4 [a b c d e f g]
        ✅: [5 6 7] = chop times 2 [5 6 7 8 9]
    
    ✅ - chop empty collection gives an empty block
        ✅: empty? chop []
        ✅: empty? chop times random 0 1000 []

Describe: Test .times's properties

    ✅ - times = size collections gives an empty block
        ✅: empty? chop times neg size [a b c] [a b c]
        ✅: empty? chop times size [a b c] [a b c]
    
    ✅ - times > size collection gives an empty block
        ✅: empty? chop times neg inc size [a b c] [a b c]
        ✅: empty? chop times inc size [a b c] [a b c]
    
    ✅ - negative times chops the first n items
        ✅: [b c] = chop times neg 1 [a b c]
        ✅: [c] = chop times neg 2 [a b c]

Describe: Test :block operations

    ✅ - chop :block returns :block
        ✅: block? chop [a b c d e f g]
        ✅: block? chop [a b]
        ✅: block? chop [a]
    
    ✅ - chop :block | in-place has the same behavior
        ✅: [a b c] = [a b c]
        ✅: [a b c] = [a b c]

Describe: Test :string operations

    ✅ - chop :string returns :string
        ✅: string? chop "High"
        ✅: string? chop "Hi"
        ✅: string? chop "H"
    
    ✅ - chop :string | in-place has the same behavior
        ✅: "Artur" = "Artur"
        ✅: "Artur" = "Artur"

======== .unitt/specs/lib/comparison/between.spec.art ========

Describe: Test generic assertions

    ✅ - Alias has the same behavior
        ✅: equal? between? 1 0 2 1 <=> 0 2
    
    ✅ - between recorgnizes numeric order
        ✅: between? 1 0 2
    
    ✅ - between recorgnizes alphabetic order
        ✅: between? "c" "a" "d"
    
    ✅ - value is between if it's equal to one of the bounds
        ✅: between? 1 1 0
        ✅: between? 1 0 1
    
    ✅ - middle is not between start..end, if middle < start
        ✅: not? between? 5 8 10
    
    ✅ - middle is not between start..end, if middle > end
        ✅: not? between? 6 1 5
    
    ✅ - works on reverse order
        ✅: between? 5 10 0
        ✅: between? "g" "z" "a"

Describe: Test numeric-like values

    ✅ - start < middle < end, for :rational and :floating
        ✅: between? 3/2 1/1 2/1
        ✅: between? 1.5 1/1 2/1
        ✅: between? 3/2 1/1 2.0
        ✅: between? 3/2 1.0 2/1
        ✅: between? 3/2 1.0 2.0
        ✅: between? 1.5 1.0 2/1
    
    ✅ - start < middle < end, for :currency
        ✅: between? 1.5 usd 1:1`usd 2:1`usd
        ✅: between? 1.5 usd 1:1`usd 2:1`usd
        ✅: between? 1.5 usd 1:1`usd 2:1`usd
        ✅: between? 1.5 usd 1:1`usd 2:1`usd
    
    ✅ - start < middle < end, for :complex's real
        ✅: between? to :complex [1 2] to :complex [0 2] to :complex [2 2]
        ✅: between? to :complex [1 2] to :complex [1 2] to :complex [2 2]
        ✅: not? between? to :complex [0 2] to :complex [1 2] to :complex [2 2]
        ✅: not? between? to :complex [3 2] to :complex [0 2] to :complex [1 2]
    
    ✅ - start < middle < end, for :complex's imaginary
        ✅: between? to :complex [1 1] to :complex [1 0] to :complex [1 2]
        ✅: between? to :complex [1 1] to :complex [1 1] to :complex [1 2]
        ✅: not? between? to :complex [1 0] to :complex [1 1] to :complex [1 2]
        ✅: not? between? to :complex [1 3] to :complex [1 0] to :complex [1 2]

Describe: Test :version values

    ✅ - first < current < final, for :version
        ✅: between? 1.0.0 0.5.0 2.1.5
        ✅: between? 1.1.0 1.0.0 1.2.0
        ✅: between? 1.1.1 1.1.0 1.1.2
    
    ✅ - prereleases always come before normal releases
        ✅: between? 1.1.1-pre 1.1.0-pre 1.1.1-pre
        ✅: between? 1.1.1-pre 1.1.0 1.1.1-pre
        ✅: between? 1.1.1-pre 1.1.0 1.1.1
        ✅: between? 1.1.1-pre 1.1.0-pre 1.1.1

Describe: Test :string-like values

    ✅ - between works with alphabetic order
        ✅: between? .c: .arturo: .ruby:
        ✅: between? .c: .arturo: .ruby:
        ✅: between? .c: .arturo: .ruby:
        ✅: between? .c: .arturo: .ruby:
        ✅: between? .c: .arturo: .ruby:
        ✅: between? .c: .arturo: .ruby:
    
    ✅ - between works for :char
        ✅: between? c b d

Describe: Test :date values

    ✅ - 15th is between 1st .. 30th for the same month
        ✅: between? to :date "0001-01-15T00:00:00-00:14" to :date "0001-01-01T00:00:00-00:14" to :date "0001-01-30T00:00:00-00:14"
    
    ✅ - June is between January and December
        ✅: between? to :date "0001-06-01T00:00:00-00:14" to :date "0001-01-01T00:00:00-00:14" to :date "0001-12-01T00:00:00-00:14"
    
    ✅ - XX century is between XIX and XXI
        ✅: between? to :date "1901-01-01T00:14:44+00:00" to :date "1801-01-01T00:00:00-00:14" to :date "2001-01-01T00:00:00+00:00"
    
    ✅ - father is between grandmother and son
        ✅: between? to :date "1980-01-17T00:05:00+00:00" to :date "1943-01-18T00:11:00+00:00" to :date "2006-01-19T00:03:00+00:00"


========== Summary ==========

  ⏏️    TOTAL: 161 assertions
  ✅  PASSED: 154 assertion
  ⏩ SKIPPED: 4 assertions
  ❌  FAILED: 3 assertion